\documentclass[11pt]{extarticle}
% \usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm}
\setlength\parindent{0pt}

\usepackage{listings}
\usepackage{courier}

\usepackage{parskip}

\usepackage{xcolor} % for setting colors

% Colors
\definecolor{lightgray}{gray}{0.95}
\definecolor{commentgreen}{rgb}{0,0.6,0}

% Code
\lstdefinestyle{manual_code}{%
	tabsize=4,
	backgroundcolor=\color{lightgray},
	commentstyle=\small\color{commentgreen},
	keywordstyle=\color{blue},
	basicstyle=\ttfamily\small,
	showtabs=false,
    showspaces=false,
    showstringspaces=false,
	breaklines=true,
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}


\title{Secure Audio DRM: System Design}
\author{Cacti}
\date{}

\begin{document}

\maketitle

\section{System Workflow and Overview}
At a high level, our system encrypts songs and authenticates users to play the songs.
In particular, we take the following steps to modify the insecure system.

\subsection{Application Design}

\begin{enumerate}
    \item DRM Header design:
    \begin{lstlisting}[language=C, label={lst:cache}, style=manual_code]
struct wav_header {
    char chunkID[4];
    uint32_t chunk_size;
    char format[4];
    char subchunk1ID[4];
    uint32_t subchunk1_size;
    uint16_t audio_fmt;
    uint16_t n_channels;
    uint32_t samplerate;
    uint32_t byterate;
    uint16_t blk_align;
    uint16_t bits_per_sample;
    char subchunk2ID[4];
    uint32_t subchunk2_size;
};
    \end{lstlisting}

    \item The following information will be securely stored and generated at build-time:
    \begin{itemize}
        \item Encryption secret key (in-bitstream w/hardware AES)
        \item Mipod public key
        \item Per-user salts
        \item Per-user public keys
        \item Per-user verification tokens (ie hashes/signatures)
    \end{itemize}

    \item The following information will be discarded after the build process is completed: Mipod public key.

    \item The following algorithms will be used:
    \begin{itemize}
        \item Hashing (KDF and signing) $\rightarrow$ SHA512;
            \begin{itemize}
                \item PBKDF2+sha512, resulting in 32-byte secret key.
                \item This takes as inputs the (nul-padded if necessary) 64-byte pin and a pregenerated per-user 64-byte salt.
            \end{itemize}
        \item Signatures $\rightarrow$ EDDSA;
        \item Encryption $\rightarrow$ AES-CBC with 128-bit keys
    \end{itemize}

    \item Communication:  Much like the reference implementation, communication will take place via gpio and shared buffers

    \item Login process: client sends username+pin, fpga copies it locally and performs the kdf on the pin.
    that is then used to compute a signature and checked against a known value success/failure is returned to the client.

    \item Play process:
    \begin{itemize}
        \item Client sends the contents of a drm file to the fpga
        \item Fpga copies the drm header and verifies its contents (good signature, song can be played for user/regions)
        \item Fpga copies sections of the song to local memory
        \item Each section is validated using the mipod public key
        \item Each validated section is then decrypted and played
        \item Should a section fail decryption or validation, the fpga stops playing the song
    \end{itemize}

    \item Share process:
    \begin{itemize}
        \item Client sends the drm header to the fpga
        \item Fpga copies the contents locally
        \item Fpga verifies its validity (good signature, owner is logged in)
        \item Fpga checks the target user to ensure they exist on the local machine
        \item Fpga adds the target user to and signs the drm share section
        \item Fpga copies the drm header back to the client
        \item Client writes the header to the file
    \end{itemize}

    \item Digitize process: same as play process, except data is written back to the shared buffer instead of played as audio
\end{enumerate}

% \subsection{Encryption Songs}

\subsection{Hardware Design}
We removed the MDM block, disabled the debug module on the MicroBlaze, and disabled the Ethernet 0 port and other unnecessary peripherals on the Zynq processor.

We have also created a hardware AES block which we can use to encrypt and decrypt parts of the songs as the application runs.
The key for this will be coded directly into the hardware at the time which we generate the bitstream.

\end{document}
